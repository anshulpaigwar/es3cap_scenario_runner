#!/usr/bin/env python

# Copyright (c) 2018 Intel Labs.
# authors: Fabian Oboril (fabian.oboril@intel.com)
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

"""
Scenarios in which another (opposite) vehicle 'illegally' takes
priority, e.g. by running a red traffic light.
"""

from __future__ import print_function
import sys

import py_trees
import carla

from srunner.scenariomanager.atomic_scenario_behavior import *
from srunner.scenariomanager.atomic_scenario_criteria import *
from srunner.scenariomanager.timer import TimeOut
from srunner.scenarios.basic_scenario import *

PEDESTRIAN_CROSSING_AUTO_GENERATED_SCENARIOS = [
    "PedestrianCrossingAutoGenerated"
]

class PedestrianCrossingAutoGenerated(BasicScenario):

    """
    This class holds everything required for a scenario,
    in which a pedestrian cross the road at red pedestrian light
    after an other vehicule passed the intersection (while the ego
    vehicle has green)

    Location: Town03
    """

    timeout = 180            # Timeout of scenario in seconds

    # moving vehicles paramters
    _expected_driven_distance = 40
    _target_velocity = 13.9
    _security_distance = 10

    _cell_distance = 4 # meters

    _cross_start_distance = 10
    _ego_vehicle_start = carla.Transform(carla.Location(x=-3.5, y=-157, z=1), carla.Rotation(yaw=90))

    _leading_vehicle_start = carla.Transform(carla.Location(x=-3.5, y=-150, z=1), carla.Rotation(yaw=90))

    _stopped_vehicle_start = carla.Transform(carla.Location(x=-13.3, y=-133, z=1), carla.Rotation(yaw=0))
   
    _intersection_location = carla.Location(x=-3.5, y=-150, z=0)
    _traffic_light_location = carla.Location(x=-11.5, y=-125.0, z=0.15)
    _traffic_light = None
    _location_of_collision = carla.Location(x=-2.8, y=-153, z=1)

    _lidar_location = carla.Transform(
        carla.Location(x=0, y=0, z=2.32),carla.Rotation(roll=0.74484513, pitch=0.85943669))
    _camera_location = carla.Transform(
        carla.Location(x= -4, y=0, z=3.5), carla.Rotation(pitch=-15))

    def __init__(self, world, ego_vehicle, other_actors, town, randomize=False, debug_mode=False, config=None):
        """
        Setup all relevant parameters and create scenario
        and instantiate scenario manager
        """
        
        # self.lidar = setup_sensor(
        #     world,
        #     "lidar",
        #     self._lidar_location,
        #     self.ego_vehicle) 
        # self.camera_rgb = setup_sensor(
        #     world,
        #     "camera.rgb",
        #     self._camera_location,
        #     self.ego_vehicle)       
        self.ego_vehicle = ego_vehicle
        self.leading_vehicle = other_actors[0]
        self.stopped_vehicle = other_actors[1]
        
        self.walker = other_actors[2]

        walker_start_loc = carla.Transform(carla.Location(x=7, y=-133, z=1), carla.Rotation(yaw=180))
        self.walker_control = carla.WalkerControl()
        self.walker_control_direction = 180 # yaw iin degrees
        self.walker_control_speed = 1.8 # m/s

        
        for actor in world.get_actors().filter('traffic.traffic_light'):
            if actor.get_location().distance(self._traffic_light_location) < 1.0:
                self._traffic_light = actor

        if self._traffic_light is None:
            print("No traffic light for the given location found")
            sys.exit(-1)

        super(PedestrianCrossingAutoGenerated, self).__init__("PedestrianCrossingAutoGenerated",
                                                ego_vehicle,
                                                other_actors,
                                                town,
                                                world,
                                                debug_mode)

    def _create_node_drive_distance(self, vehicle, distance, speed, vehicle_name):
        travel_distance = py_trees.composites.Parallel("Keep velocity {} m/s for {} meters".format(speed, distance), policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ONE)
        keep_velocity = KeepVelocityPID(vehicle, speed, name="Velocity {} m/s".format(speed))
        check_distance = DriveDistance(vehicle, distance, name="Distance {} meters".format(distance))
        travel_distance.add_child(keep_velocity)
        travel_distance.add_child(check_distance)
        
        stop = StopVehicle(vehicle, 1, name="Stop {}".format(vehicle_name))
        
        travel_distance_then_stop = py_trees.composites.Sequence("Vehicle {} drives for {} meters at {} m/s ".format(vehicle_name, distance, speed))
        travel_distance_then_stop.add_child(travel_distance)
        travel_distance_then_stop.add_child(stop)

        return travel_distance_then_stop

    def _create_node_walk_distance(self, walker, distance, speed):
        travel_distance = py_trees.composites.Parallel("Keep velocity {} m/s for {} meters".format(speed, distance), policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ONE)
        keep_velocity = KeepVelocity_pedestrian(walker, speed, name="Velocity {} m/s".format(speed))
        check_distance = DriveDistance(walker, distance, name="Distance {} meters".format(distance))
        travel_distance.add_child(keep_velocity)
        travel_distance.add_child(check_distance)
        
        # stop = StopVehicle(walker, 1, name="Stop {}".format(vehicle_name))
        
        travel_distance_then_stop = py_trees.composites.Sequence("Walker walks for {} meters at {} m/s ".format(distance, speed))
        travel_distance_then_stop.add_child(travel_distance)
        # travel_distance_then_stop.add_child(stop)

        return travel_distance_then_stop

    def _create_behavior(self):
        """
        Scenario behavior:
        The other vehicle waits until the ego vehicle is close enough to the
        intersection and that its own traffic light is red. Then, it will start
        driving and 'illegally' cross the intersection. After a short distance
        it should stop again, outside of the intersection. The ego vehicle has
        to avoid the crash, but continue driving after the intersection is clear.

        If this does not happen within 120 seconds, a timeout stops the scenario
        """

        # sequence automaticaly generated 
        # Build behavior tree
        sequence = py_trees.composites.Sequence("Sequence Behavior")
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        # ego vehicle blocked because the leading vehicle has not moved yet
        sequence.add_child(IDLE(1, name="Ego vehicle idle"))
        sequence.add_child(IDLE(1, name="Ego vehicle idle"))
        sequence.add_child(IDLE(1, name="Ego vehicle idle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        sequence.add_child(IDLE(1, name="Ego vehicle idle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        # Leading vechicle passed the intersection
        sequence.add_child(self._create_node_walk_distance(self.walker, self._cell_distance, 2)
        sequence.add_child(self._create_node_walk_distance(self.walker, self._cell_distance, 2)
        sequence.add_child(self._create_node_walk_distance(self.walker, self._cell_distance, 2)
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        sequence.add_child(self._create_node_walk_distance(self.walker, self._cell_distance, 2)
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        # collision: ego vehicle into walker !!
        # 10 sec wait until terminate
        sequence.add_child(IDLE(10, name="10 sec wait until terminate"))
        return sequence

    def _create_test_criteria(self):
        """
        A list of all test criteria will be created that is later used
        in parallel behavior tree.
        """
        criteria = []

        # velocity_criterion = AverageVelocityTest(self.ego_vehicle, self._target_velocity)
        # collision_criterion = CollisionTest(self.ego_vehicle)
        # driven_distance_criterion = DrivenDistanceTest(self.ego_vehicle, self._expected_driven_distance)
        # criteria.append(velocity_criterion)
        # # criteria.append(collision_criterion)
        # criteria.append(driven_distance_criterion)

        velocity_criterion = AverageVelocityTest(self.leading_vehicle, self._target_velocity)
        collision_criterion = CollisionTest(self.leading_vehicle)
        driven_distance_criterion = DrivenDistanceTest(self.leading_vehicle, self._expected_driven_distance)
        criteria.append(velocity_criterion)
        # criteria.append(collision_criterion)
        criteria.append(driven_distance_criterion)

        # velocity_criterion = AverageVelocityTest(self.other_vehicles[1], 0)
        # collision_criterion = CollisionTest(self.other_vehicles[1])
        # criteria.append(velocity_criterion)
        # criteria.append(collision_criterion)

        return criteria

    def __del__(self):
        self._traffic_light = None
        super(PedestrianCrossingAutoGenerated, self).__del__()