#!/usr/bin/env python

# Copyright (c) 2018 Intel Labs.
# authors: Fabian Oboril (fabian.oboril@intel.com)
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

"""
Scenarios in which another (opposite) vehicle 'illegally' takes
priority, e.g. by running a red traffic light.
"""

from __future__ import print_function
import sys
import json

import py_trees
import carla

from srunner.scenariomanager.atomic_scenario_behavior import *
from srunner.scenariomanager.atomic_scenario_criteria import *
from srunner.scenariomanager.timer import TimeOut
from srunner.scenarios.basic_scenario import *

PEDESTRIAN_CROSSING_AUTO_GENERATED_SCENARIOS = [
    "PedestrianCrossingAutoGenerated"
]


class SequenceStep(object):
    """
    A step of the sequence.
    Only movements of an actor are supported as step
    """
    def __init__(self, dict_step):
        self.actor = dict_step["actor"]
        self.id = dict_step["id"]
        self.required_by = dict_step["required_by"]
        self.action = dict_step["action"]
        if self.actor == "walker": # TODO: Harcoded
            self.loc = self.point_tf_to_carla(dict_step["next_location"]["x"], dict_step["next_location"]["y"], scale=2.5)
        else:
            self.loc = self.point_tf_to_carla(dict_step["next_location"]["x"], dict_step["next_location"]["y"])

    def point_tf_to_carla(slf,x, y, scale=5):
        # each unitary movement from the sequence is 5m in the simulator, x and y axis are inverted
        # collision happens at -3.5, -133 in the simulator (6,3 in the sequence)
        # TODO: hard coded collision location
        x_ = scale*(6-x) - 3.5
        y_ = scale*(3-y) - 133
        z_ = 0 # arbitrary, for test purpose
        return carla.Location(x=x_, y=y_, z=z_)


    def __str__(self):
        return "{}: action {} of id {} to {}, required by {}".format(self.actor, self.action, self.id, self.loc, self.required_by)

class RawSequence(object):
    """Raw sequence from the generator"""
    def __init__(self, file_name):
        with open(file_name, 'r') as f:
            self.original_sequence = json.load(f)
        self.sort_by_actor()
        self.parallelize_sequence()

    def sort_by_actor(self):
        self.actor_sorted_sequence = {} # {"actor": [[carla.Location n0], ...], ...}
        for actor in self.original_sequence["actors"]:
            # loc = point_tf_to_carla(actor["start_location"]["x"], actor["start_location"]["y"])
            self.actor_sorted_sequence[actor["name"]] =[] 
        for step in self.original_sequence["sequence"]:
            if step["action"] == "move":
                self.actor_sorted_sequence[step["actor"]] += [SequenceStep(step)]
            # elif step["idle"] == "move": # idle steps are ignored 
    
    def is_sorted_sequence_empty(self):
        for seq in self.actor_sorted_sequence.values():
            if seq:
                return False
        return True

    def dependencies_satisfied(self, step):
        for step_id in step.required_by:
            for seq_ in self.actor_sorted_sequence.values():
                for step_ in seq_:
                    if step_id == step_.id:
                        return False
        return True

    # create a parallelized sequence from actor_sorted_sequence but empties it during the call then restores it from a copy
    def parallelize_sequence(self):
        self.sequence = []
        self.actor_sorted_sequence_copy = {actor: [] for actor in self.actor_sorted_sequence}
        while not self.is_sorted_sequence_empty():
            parallel_steps = []
            for actor, seq in self.actor_sorted_sequence.iteritems():
                if seq:
                    step = seq.pop()
                    if self.dependencies_satisfied(step):
                        parallel_steps += [step]
                        self.actor_sorted_sequence_copy[actor] += [step]
                    else:
                        seq += [step]

            if not parallel_steps:
                self.display_actor_seq()
                raise Exception("Parallelization blocked, can't resolve dependencies")
            else:
                self.sequence += [parallel_steps]
        for value in self.actor_sorted_sequence_copy.values():
            value.reverse()
        self.actor_sorted_sequence = self.actor_sorted_sequence_copy
        self.sequence.reverse()

    """
    Display the actor_sorted_sequence, will print empty lists after parallelize_sequence
    """
    def display_actor_seq(self):
        print("{:^30}".format("ACTOR SEQUENCE"))
        for actor in self.actor_sorted_sequence:
            print("{}".format(actor))
            for step in self.actor_sorted_sequence[actor]:
                print("    {}".format(step))
    
    def display_seq(self):
        print("{:^30}".format("SEQUENCE"))
        for i, steps in enumerate(self.sequence):
            print("Seq step {}".format(i))
            for step in steps:
                print("    {}".format(step))

class SharedRessources(object):
    def __init__(self):
        self.speeds = {} 
    
class PedestrianCrossingAutoGenerated(BasicScenario):
    """
    This class holds everything required for a scenario,
    in which a pedestrian cross the road at red pedestrian light
    after an other vehicule passed the intersection (while the ego
    vehicle has green)

    Location: Town03
    """

    timeout = 5000 # Timeout of scenario in seconds

    # moving vehicles paramters
    _expected_driven_distance = 40
    _target_velocity = 13.9
    _security_distance = 10

    _cell_distance = 5 # meters
    _cell_distance_walker = 2.5 # meters
    _vehicle_speed = 5
    _walker_speed = 0.5
    _distance_to_location = 1
    _cross_start_distance = 10
    _ego_vehicle_start = carla.Transform(carla.Location(x=-3.5, y=-157, z=1), carla.Rotation(yaw=90))

    _leading_vehicle_start = carla.Transform(carla.Location(x=-3.5, y=-150, z=1), carla.Rotation(yaw=90))

    _stopped_vehicle_start = carla.Transform(carla.Location(x=-13.3, y=-133, z=1), carla.Rotation(yaw=0))
   
    _intersection_location = carla.Location(x=-3.5, y=-150, z=0)
    _traffic_light_location = carla.Location(x=-11.5, y=-125.0, z=0.15)
    _traffic_light = None
    _location_of_collision = carla.Location(x=-3.5, y=-133, z=1)

    _lidar_location = carla.Transform(
        carla.Location(x=0, y=0, z=2.32),carla.Rotation(roll=0.74484513, pitch=0.85943669))
    _camera_location = carla.Transform(
        carla.Location(x= -4, y=0, z=3.5), carla.Rotation(pitch=-15))

    def __init__(self, world, ego_vehicle, other_actors, town, randomize=False, debug_mode=False, sequence_file=""):
        """
        Setup all relevant parameters and create scenario
        and instantiate scenario manager
        """
        
        # self.lidar = setup_sensor(
        #     world,
        #     "lidar",
        #     self._lidar_location,
        #     self.ego_vehicle) 
        # self.camera_rgb = setup_sensor(
        #     world,
        #     "camera.rgb",
        #     self._camera_location,
        #     self.ego_vehicle)       
        self.ego_vehicle = ego_vehicle
        self.leading_vehicle = other_actors[0]
        self.stopped_vehicle = other_actors[1]
        
        self.walker = other_actors[2]

        walker_start_loc = carla.Transform(carla.Location(x=7, y=-133, z=1), carla.Rotation(yaw=180))
        self.walker_control = carla.WalkerControl()
        self.walker_control_direction = 180 # yaw in degrees
        self.walker_control_speed = 1.8 # m/s

        self.shared_ressources = SharedRessources()
        
        for actor in world.get_actors().filter('traffic.traffic_light'):
            if actor.get_location().distance(self._traffic_light_location) < 1.0:
                self._traffic_light = actor

        if self._traffic_light is None:
            print("No traffic light for the given location found")
            sys.exit(-1)

        self.sequence = RawSequence("./srunner/configs/seq1.json") # TODO: hard coded file name
        
        self.sequence.display_actor_seq()
        self.sequence.display_seq()

        super(PedestrianCrossingAutoGenerated, self).__init__("PedestrianCrossingAutoGenerated",
                                                ego_vehicle,
                                                other_actors,
                                                town,
                                                world,
                                                debug_mode)

    def _create_node_drive_distance(self, vehicle, distance, speed, vehicle_name):
        travel_distance = py_trees.composites.Parallel("Keep velocity {} m/s for {} meters".format(speed, distance), policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ONE)
        keep_velocity = KeepVelocity(vehicle, speed, name="Velocity {} m/s".format(speed))
        check_distance = DriveDistance(vehicle, distance, name="Distance {} meters".format(distance))
        travel_distance.add_child(keep_velocity)
        travel_distance.add_child(check_distance)
        
        stop = StopVehicle(vehicle, 1, name="Stop {}".format(vehicle_name))
        
        travel_distance_then_stop = py_trees.composites.Sequence("Vehicle {} drives for {} meters at {} m/s ".format(vehicle_name, distance, speed))
        travel_distance_then_stop.add_child(travel_distance)
        travel_distance_then_stop.add_child(stop)

        return travel_distance_then_stop
        
    def _create_node_walk_distance(self, walker, distance, speed):
        travel_distance = py_trees.composites.Parallel("Keep velocity {} m/s for {} meters".format(speed, distance), policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ONE)
        keep_velocity = KeepVelocity_pedestrian(walker, speed, 180, name="Velocity {} m/s".format(speed))
        check_distance = DriveDistance(walker, distance, name="Distance {} meters".format(distance))
        travel_distance.add_child(keep_velocity)
        travel_distance.add_child(check_distance)
        
        # stop = StopVehicle(walker, 1, name="Stop {}".format(vehicle_name))
        
        travel_distance_then_stop = py_trees.composites.Sequence("Walker walks for {} meters at {} m/s ".format(distance, speed))
        travel_distance_then_stop.add_child(travel_distance)
        # travel_distance_then_stop.add_child(stop)

        return travel_distance_then_stop


    def _create_simple_behavior(self):
        sequence = py_trees.composites.Sequence("Sequence Behavior")
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        # ego vehicle blocked because the leading vehicle has not moved yet
        sequence.add_child(IDLE(1, name="Ego vehicle idle"))
        sequence.add_child(IDLE(1, name="Ego vehicle idle"))
        sequence.add_child(IDLE(1, name="Ego vehicle idle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        sequence.add_child(IDLE(1, name="Ego vehicle idle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        # Leading vechicle passed the intersection
        sequence.add_child(self._create_node_walk_distance(self.walker, self._cell_distance_walker, 0.5))
        sequence.add_child(self._create_node_walk_distance(self.walker, self._cell_distance_walker, 0.5))
        sequence.add_child(self._create_node_walk_distance(self.walker, self._cell_distance_walker, 0.5))
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        sequence.add_child(self._create_node_walk_distance(self.walker, self._cell_distance_walker, 0.5))
        sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        # collision: ego vehicle into walker !!
        # 10 sec wait until terminate
        sequence.add_child(IDLE(10, name="10 sec wait until terminate"))
        return sequence
    

    def _create_simple_parallelized_behavior(self):
        behaviour_tree = py_trees.composites.Sequence("Sequence Behavior")
        
        for i, steps in enumerate(self.sequence.sequence):
            state = py_trees.composites.Parallel("State {}".format(i), policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ALL)
            for step in steps:
                # TODO: hard coded vehicle selection
                if step.actor == "ego":
                    state.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, self._vehicle_speed, "Ego vehicle"))
                elif step.actor == "leading":
                    state.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, self._vehicle_speed, "Leading vehicle"))
                elif step.actor == "walker":
                    state.add_child(self._create_node_walk_distance(self.walker, self._cell_distance_walker, self._walker_speed))
                else:
                    raise Exception("Unknown acto '{}' in sequence, can't associate actor".format(step.actor))
            behaviour_tree.add_child(state)
        return behaviour_tree


    def _node_drive_to_point(self, vehicle, vehicle_name, location):
        drive_to_loc = py_trees.composites.Parallel("{} drives to {}".format(vehicle_name, location), policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ONE)
        keep_velocity = KeepSharedVelocityPID(vehicle, vehicle_name, self.shared_ressources, name="Dynamic velocity")
        check_location = InTriggerDistanceToLocation(vehicle, location, self._distance_to_location, name="Destination {}".format(location))
        drive_to_loc.add_children([keep_velocity, check_location])
        return drive_to_loc

    def _node_walk_to_point(self, walker, walker_name, location):
        walk_to_loc = py_trees.composites.Parallel("{} walks to {}".format(walker_name, location), policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ONE)
        keep_velocity = KeepSharedVelocity_pedestrian(walker, walker_name, self.shared_ressources, 180, name="Dynamic velocity") # TODO; hard coded orientation
        check_location = InTriggerDistanceToLocation(walker, location, self._distance_to_location, name="Destination {}".format(location))
        walk_to_loc.add_children([keep_velocity, check_location])
        return walk_to_loc

    def _create_parallelized_behavior(self):
        behaviour_tree = py_trees.composites.Sequence("Sequence Behavior")
        
        for i, steps in enumerate(self.sequence.sequence):
        
            apply_speed = py_trees.composites.Parallel("Apply speed to actors", policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ONE) #TODO: maybe set to SUCCESS_ON_ONE ?
            actors_dict = []
            for step in steps:
                # TODO: hard coded vehicle selection
                if step.actor == "ego":
                    apply_speed.add_child(self._node_drive_to_point(self.ego_vehicle, "ego", step.loc))
                    actors_dict += [{"name": "ego", "actor": self.ego_vehicle, "dest": step.loc, "vmax": self._vehicle_speed}]
                    pass
                elif step.actor == "leading":
                    apply_speed.add_child(self._node_drive_to_point(self.leading_vehicle, "leading", step.loc))
                    actors_dict += [{"name": "leading", "actor": self.leading_vehicle, "dest": step.loc, "vmax": self._vehicle_speed}]
                elif step.actor == "walker":
                    apply_speed.add_child(self._node_walk_to_point(self.walker, "walker", step.loc))
                    actors_dict += [{"name": "walker", "actor": self.walker, "dest": step.loc, "vmax": self._walker_speed}]
                    pass
                else:
                    raise Exception("Unknown acto '{}' in sequence, can't associate actor".format(step.actor))
            state = py_trees.composites.Parallel("State {}".format(i), policy=py_trees.common.ParallelPolicy.SUCCESS_ON_ONE)
            state.add_child(ComputeSpeedFactor(actors_dict, self.shared_ressources))
            state.add_child(apply_speed)

            behaviour_tree.add_child(state)
        behaviour_tree.add_child(IDLE(10, name="10 sec wait until terminate"))
            
        return behaviour_tree
        
    def _create_behavior(self):
        """
        Scenario behavior:
        The other vehicle waits until the ego vehicle is close enough to the
        intersection and that its own traffic light is red. Then, it will start
        driving and 'illegally' cross the intersection. After a short distance
        it should stop again, outside of the intersection. The ego vehicle has
        to avoid the crash, but continue driving after the intersection is clear.

        If this does not happen within 120 seconds, a timeout stops the scenario
        """
        node_seq_inversed = []

        # sequence automaticaly generated 
        # Build behavior tree


        behaviour_tree = self._create_parallelized_behavior()

        # sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        # sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        # # ego vehicle blocked because the leading vehicle has not moved yet
        # sequence.add_child(IDLE(1, name="Ego vehicle idle"))
        # sequence.add_child(IDLE(1, name="Ego vehicle idle"))
        # sequence.add_child(IDLE(1, name="Ego vehicle idle"))
        # sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        # sequence.add_child(IDLE(1, name="Ego vehicle idle"))
        # sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        # sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        # sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        # sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        # sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        # sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        # sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        # sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        # sequence.add_child(self._create_node_drive_distance(self.leading_vehicle, self._cell_distance, 4, "Leading vehicle"))
        # # Leading vechicle passed the intersection
        # sequence.add_child(self._create_node_walk_distance(self.walker, self._cell_distance_walker, 0.5))
        # sequence.add_child(self._create_node_walk_distance(self.walker, self._cell_distance_walker, 0.5))
        # sequence.add_child(self._create_node_walk_distance(self.walker, self._cell_distance_walker, 0.5))
        # sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        # sequence.add_child(self._create_node_walk_distance(self.walker, self._cell_distance_walker, 0.5))
        # sequence.add_child(self._create_node_drive_distance(self.ego_vehicle, self._cell_distance, 4, "Ego vehicle"))
        # # collision: ego vehicle into walker !!
        # # 10 sec wait until terminate
        # sequence.add_child(IDLE(10, name="10 sec wait until terminate"))
        return behaviour_tree

    def _create_test_criteria(self):
        """
        A list of all test criteria will be created that is later used
        in parallel behavior tree.
        """
        criteria = []

        # velocity_criterion = AverageVelocityTest(self.ego_vehicle, self._target_velocity)
        # collision_criterion = CollisionTest(self.ego_vehicle)
        # driven_distance_criterion = DrivenDistanceTest(self.ego_vehicle, self._expected_driven_distance)
        # criteria.append(velocity_criterion)
        # # criteria.append(collision_criterion)
        # criteria.append(driven_distance_criterion)

        velocity_criterion = AverageVelocityTest(self.leading_vehicle, self._target_velocity)
        collision_criterion = CollisionTest(self.leading_vehicle)
        driven_distance_criterion = DrivenDistanceTest(self.leading_vehicle, self._expected_driven_distance)
        criteria.append(velocity_criterion)
        # criteria.append(collision_criterion)
        criteria.append(driven_distance_criterion)

        # velocity_criterion = AverageVelocityTest(self.other_vehicles[1], 0)
        # collision_criterion = CollisionTest(self.other_vehicles[1])
        # criteria.append(velocity_criterion)
        # criteria.append(collision_criterion)

        return criteria

    def __del__(self):
        self._traffic_light = None
        super(PedestrianCrossingAutoGenerated, self).__del__()